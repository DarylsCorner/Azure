<#	
	.NOTES
	===========================================================================
	 Created on:   	12/14/2015 4:53 PM
	 Created by:   	Daryl Harrington
	 Organization: 	 
	 Filename:     	Deploy-CustomImage
	===========================================================================
	.DESCRIPTION
		Notes: Microsoft Azure powershell module v0.9.8 was used when running these commands. Run commands interactively to perform end-to-end provisioning.
#>

#region Authenticate to Azure
Add-AzureAccount
#endregion Authenticate to Azure

#region Switch to Azure Resource Manager Mode

Switch-AzureMode -Name AzureResourceManager

#endregion Switch to Azure Resource Manager Mode

#region Select an Azure subscription (make choice)

$subscriptionId = (Get-AzureSubscription | Out-GridView -Title "Select a Subscription ..." -PassThru).SubscriptionId

Select-AzureSubscription -SubscriptionId $subscriptionId

#endregion Select an Azure subscription (make choice)

#region Select an Azure Datacenter Region (make choice)

$location = (Get-AzureLocation | Where-Object Name -eq "ResourceGroup").Locations | Out-GridView -Title "Select a Region ..." -PassThru

# Show available Providers $ Resource Types available in that Region (info only))
(Get-AzureLocation | Where-Object Locations -Contains $location).Name

#endregion Select an Azure Datacenter Region 

#region Create Azure Resource Group

# Define a unique prefix for naming resources
$prefix = "XXX" # Replace XXX with unique lowercase value

# Define custome tags
$tags = New-Object System.Collections.ArrayList
$tags.Add(@{ Name = "project"; Value = "dev" })
$tags.Add(@{ Name = "costCenter"; Value = "0001" })

# Define number of VMs to provision in Resource Group
$VmInstances = 2

# Create Resource Group if it doesn't exist already
$rgName = "${prefix}-rg"

If (!(Test-AzureResourceGroup -ResourceGroupName $rgName))
{
	$rg = New-AzureResourceGroup -Name $rgName -Location $location -Tag $tags
}
Else
{
	# Get Resource Group if already created
	$rg = Get-AzureResourceGroup -Name $rgName
}
#endregion Create Azure Resource Group

#region Create Azure Storage Account

# Define a unique name for the new Storage Account
$storageAccountName = 'yourStorageAccount'
$storageAccountType = 'Standard_LRS'


# Create Storage Account if it doesn't exist
if (!(Test-AzureResource -ResourceName $storageAccountName -ResourceType "Microsoft.Storage/storageAccounts" -ResourceGroupName $rgName))
{
	$storageAccount = New-AzureStorageAccount -Name $storageAccountName -ResourceGroupName $rgName -Location $location -Type $storageAccountType
}
else
{
	# Get Storage Account if already created
	$storageAccount = Get-AzureStorageAccount -ResourceGroupName $rgname -Name $storageAccountName
}

# Set new Storage Account as default
Set-AzureSubscription -SubscriptionId $subscriptionId -CurrentStorageAccountName $storageAccountName

#endregion Create Azure Storage Account 

#region Move Azure Image Template

# Copy VHDs to new storage account
#Define the source storage account and context.
$SourceStorageAccountName = "yourSourceStorageAccount"
$SourceStorageAccountKey = (Get-AzureStorageAccountKey -ResourceGroupName gwpccisco-rg2 -Name $SourceStorageAccountName).Key1
$SrcContainerName = "system"
$SourceContext = New-AzureStorageContext -StorageAccountName $SourceStorageAccountName -StorageAccountKey $SourceStorageAccountKey

#Define the destination storage account and context.
$DestStorageAccountName = 'yourDestinationStorageAccount'
$DestStorageAccountKey = (Get-AzureStorageAccountKey -ResourceGroupName $rgName -Name $DestStorageAccountName).Key1
$DestContainerName = 'myimages'
$DestContext = New-AzureStorageContext -StorageAccountName $DestStorageAccountName -StorageAccountKey $DestStorageAccountKey

#Create new container to hold copies of image templates for OS/Data disk
New-AzureStorageContainer -Name $DestContainerName -Permission Off -Context $DestContext

#Reference blobs in the source container with disk in the name.
$blobs = Get-AzureStorageBlob -Container $SrcContainerName -Context $SourceContext -Blob '*disk*'

#Copy blobs from one container to another.
$blobs | Start-AzureStorageBlobCopy -DestContainer $DestContainerName -DestContext $DestContext

#endregion Move Azure Image Template

#region Create Virtual Network

# Define a unique name for the Azure VNET
$vnetName = "${prefix}-vnet1"

# Define names for each Subnet within the VNET
$subnet1Name = "GatewaySubnet"
$subnet2Name = "${prefix}-subnet02"


# Create Virtual Network if it doesn't exist
if (!(Test-AzureResource -ResourceName $vnetName -ResourceType "Microsoft.Network/virtualNetworks" -ResourceGroupName $rgName))
{
	$subnet1 = New-AzureVirtualNetworkSubnetConfig -Name $subnet1Name -AddressPrefix "10.0.1.0/28"
	$subnet2 = New-AzureVirtualNetworkSubnetConfig -Name $subnet2Name -AddressPrefix "10.0.2.0/24"
	$vnet = New-AzureVirtualNetwork -Name $vnetName -ResourceGroupName $rgName -Location $location -AddressPrefix "10.0.0.0/20" -Subnet $subnet1, $subnet2 -Tag $tags
}
else
{
	# Get Virtual Network if already created
	$vnet = Get-AzureVirtualNetwork -Name $vnetName -ResourceGroupName $rgName
}

#endregion Create Virtual Network

#region Define Network Security Group Rules

# Define unique name for NSG resource

$nsgName = "${prefix}-nsg1"

# Create NSG if it doesn't exist 
if (!(Test-AzureResource -ResourceName $nsgName -ResourceType "Microsoft.Network/networkSecurityGroups" -ResourceGroupName $rgName))
{
	# Sample rule – currently permits RDP from all source IPs
	$nsgRule1 = New-AzureNetworkSecurityRuleConfig -Name "allow-rdp-inbound" -Description "Allow Inbound RDP" -SourceAddressPrefix * -DestinationAddressPrefix * -Protocol Tcp -SourcePortRange * -DestinationPortRange 3389 -Direction Inbound -Access Allow -Priority 100
	
	# Sample rule – currently permits HTTP from all source IPs
	#$nsgRule2 = New-AzureNetworkSecurityRuleConfig -Name "allow-http-inbound" -Description "Allow Inbound HTTP" -SourceAddressPrefix * -DestinationAddressPrefix * -Protocol Tcp -SourcePortRange * -DestinationPortRange 80 -Direction Inbound -Access Allow -Priority 110
	
	# Create NSG using rules defined above
	$nsg = New-AzureNetworkSecurityGroup -Name $nsgName -ResourceGroupName $rgName -Location $location -SecurityRules $nsgRule1 -Tag $tags
}
else
{
	# Get NSG if already created
	$nsg = Get-AzureNetworkSecurityGroup -Name $nsgName -ResourceGroupName $rgName
}

#endregion Define Network Security Group Rules

#region Define a Instance-Level PIP Address for servers
# Define an empty array for holding PIP configs for each Server VM
$pips = @()

# Create each PIP if not already created
for ($count = 1; $count -le $VmInstances; $count++)
{
	$pipName = "${prefix}-nic-pip${count}"
	$domainName = "${prefix}-vm${count}"
	
	if (!(Test-AzureResource -ResourceName $pipName -ResourceType "Microsoft.Network/publicIPAddresses" -ResourceGroupName $rgName))
	{
		$pipIndex = $count – 1
		
		# Create each new PIP
		$pips += New-AzurePublicIpAddress -Name $pipName -ResourceGroupName $rgName -Location $location -AllocationMethod Dynamic -DomainNameLabel $domainName -Tag $tags
	}
	else
	{
		# Get each PIP if already created
		$pips += New-AzurePublicIpAddress -Name $pipName -ResourceGroupName $rgName
	}
}
#endregion Define a Instance-Level PIP Address for servers

#region Define Network Interfaces for servers

# Define an empty array for holding NIC configs for each Terminal Server VM
$nics = @()

# Create each NIC if not already created
for ($count = 1; $count -le $VmInstances; $count++)
{
	$nicName = "${prefix}-term-nic${count}"
	
	if (!(Test-AzureResource -ResourceName $nicName -ResourceType "Microsoft.Network/networkInterfaces" -ResourceGroupName $rgName))
	{
		$nicIndex = $count – 1
		
		# Attach each NIC to related Subnet, and NSG rules
		$nics += New-AzureNetworkInterface -Name $nicName -ResourceGroupName $rgName -Location $location -SubnetId $vnet.Subnets[1].Id -PublicIpAddressId $pips[$nicIndex].Id -NetworkSecurityGroupId $nsg.Id -Tag $tags
	}
	else
	{
		# Get each NIC if already created
		$nics += Get-AzureNetworkInterface -Name $nicName -ResourceGroupName $rgName
	}
}


#endregion Define Network Interfaces for servers

#region Create Availability Sets for servers

# Define an empty array for holding Availability Set configs for Terminal Server VMs

# Define number of Availability Sets to create
$asInstances = 1
$avSet = @()

# Create Availability Set if it doesn't exist
for ($count = 1; $count -le $asInstances; $count++)
{
	$avSetName = "${prefix}-as${count}"
	
	if (!(Test-AzureResource -ResourceName $avSetName -ResourceType "Microsoft.Compute/availabilitySets" -ResourceGroupName $rgName))
	{
		$asIndex = $count - 1
		
		$avSet += New-AzureAvailabilitySet -Name $avSetName -ResourceGroupName $rgName -Location $location
	}
	else
	{
		# Get Availability Set if already created
		$avSet += Get-AzureAvailabilitySet -Name $avSetName -ResourceGroupName $rgName
	}
	
}

#endregion Create Availability Sets for servers

#region Provision each Virtual Machine for Servers

# Select an Azure VM Instance Size (ex. Standard_A1)
$vmSize = (Get-AzureVMSize -Location $location |
Select-Object Name, NumberOfCores, MemoryInMB, MaxDataDiskCount |
Out-GridView -Title "Select a VM Instance Size" -PassThru).Name

# Specify VM local Admin credentials (administrator not allowed)
$vmAdminCreds = Get-Credential -Message "Enter Local Admin creds for new VMs ..."

# For each VM, build configuration and provision
$VmInstances = 2
$vm = @()

for ($count = 1; $count -le $VmInstances; $count++)
{
	$vmName = "${prefix}-vm${count}"
	
	if (!(Test-AzureResource -ResourceName $vmName -ResourceType "Microsoft.Compute/virtualMachines" -ResourceGroupName $rgName))
	{
		$vmIndex = $count - 1
		$osDiskLabel = "OSDisk"
		$osDiskName = "${vmName}-osdisk"
		$osDiskUri = $storageAccount.PrimaryEndpoints.Blob.ToString() + "vhds/${osDiskName}.vhd"
		$sourceImageUri = 'https://yourStorageAccount.blob.core.windows.net/myimages/Microsoft.Compute/Images/myimages/template-osDisk.cc51b4fb-1755-4d43-ae6b-e93b277980f2.vhd'
		$dataDiskSize = 1023 # Size in GB
		$dataDiskLabel = "DataDisk01"
		$dataDiskName = "${prefix}-${vmName}-datadisk01"
		$dataDiskUri = $storageAccount.PrimaryEndpoints.Blob.ToString() + "vhds/${dataDiskName}.vhd"
		$sourceDataDiskImageUri = 'https://yourStorageAccount.blob.core.windows.net/myimages/Microsoft.Compute/Images/myimages/template-dataDisk-0.cc51b4fb-1755-4d43-ae6b-e93b277980f2.vhd'
		
		$vmConfig = New-AzureVMConfig -VMName $vmName -VMSize $vmSize -AvailabilitySetId $avSet[0].Id |
		Set-AzureVMOperatingSystem -Windows -ComputerName $vmName -Credential $vmAdminCreds -ProvisionVMAgent -EnableAutoUpdate |
		Set-AzureVMOSDisk -Name $osDiskLabel -VhdUri $osDiskUri -CreateOption fromImage -SourceImageUri $sourceImageUri -Windows |
		Add-AzureVMDataDisk -Name $dataDiskLabel -DiskSizeInGB $dataDiskSize -VhdUri $dataDiskURI -CreateOption fromImage -SourceImageUri $sourceDataDiskImageUri |
		Add-AzureVMNetworkInterface -Id $nics[$vmIndex].Id -Primary
		
		New-AzureVM -VM $vmConfig -ResourceGroupName $rgName -Location $location -Tags $tags
	}
	
	# Get the VM if already provisioned
	$vm += Get-AzureVM -Name $vmName -ResourceGroupName $rgName
}

#endregion Provision each Virtual Machine for Servers

#region Delete container storing copied images

Get-AzureStorageContainer -Name myimages -Context $DestContext | Remove-AzureStorageContainer -Force

#endregion Delete container storing copied images

